import os
import sys
import shutil
from pathlib import Path
from typing import Optional
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

# Ensure Backend is on sys.path for local script execution
BACKEND_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if BACKEND_DIR not in sys.path:
    sys.path.insert(0, BACKEND_DIR)

from validation.inputs import non_empty_string

# Store keys in user's home directory for better security
KEY_DIR = Path.home() / ".stegocrypt_keys"
KEY_DIR.mkdir(exist_ok=True)

PRIVATE_KEY_FILE = KEY_DIR / "private_rsa.pem"
PUBLIC_KEY_FILE = KEY_DIR / "public_rsa.pem"

def generate_rsa_keys(output_dir: Optional[str] = None):
    """
    Generates a new RSA key pair.
    If output_dir is provided, saves keys to that directory.
    Otherwise, saves to the default location.
    """
    key = RSA.generate(2048)
    private_key_pem = key.export_key()
    public_key_pem = key.publickey().export_key()

    if output_dir:
        dest_dir = Path(output_dir)
        dest_dir.mkdir(parents=True, exist_ok=True)
        private_key_path = dest_dir / "private_rsa.pem"
        public_key_path = dest_dir / "public_rsa.pem"
    else:
        private_key_path = PRIVATE_KEY_FILE
        public_key_path = PUBLIC_KEY_FILE

    with open(private_key_path, 'wb') as f:
        f.write(private_key_pem)
    with open(public_key_path, 'wb') as f:
        f.write(public_key_pem)

    # Also update the default key location if a custom directory is used
    if output_dir:
        with open(PRIVATE_KEY_FILE, 'wb') as f:
            f.write(private_key_pem)
        with open(PUBLIC_KEY_FILE, 'wb') as f:
            f.write(public_key_pem)
            
    return private_key_path, public_key_path

def load_keys():
    """Returns None for both keys to indicate no keys are loaded by default.
    Keys must be explicitly imported or generated by the user."""
    return None, None

def _load_existing_keys():
    """Actually loads RSA keys from the default location if they exist.
    This function should only be called when explicitly needed."""
    private_key = None
    public_key = None
    
    try:
        if PRIVATE_KEY_FILE.exists():
            with open(PRIVATE_KEY_FILE, 'rb') as f:
                private_key = RSA.import_key(f.read())
    except Exception as e:
        print(f"Warning: Could not load private key: {e}")
    
    try:
        if PUBLIC_KEY_FILE.exists():
            with open(PUBLIC_KEY_FILE, 'rb') as f:
                public_key = RSA.import_key(f.read())
    except Exception as e:
        print(f"Warning: Could not load public key: {e}")
        
    return private_key, public_key

def encrypt_with_rsa(public_key, message: str) -> bytes:
    """Encrypt plaintext string using the public key and return raw bytes."""
    non_empty_string(message, "message")
    
    if public_key is None:
        raise ValueError("Public key not available. Please import or generate a public key before encoding.")
        
    cipher = PKCS1_OAEP.new(public_key)
    ciphertext = cipher.encrypt(message.encode('utf-8'))
    return ciphertext

def decrypt_with_rsa(private_key, ciphertext: bytes) -> str:
    """Decrypt ciphertext bytes using the private key and return plaintext string."""
    if private_key is None:
        raise ValueError("Private key not available. Please import or generate a private key before decoding.")
        
    cipher = PKCS1_OAEP.new(private_key)
    return cipher.decrypt(ciphertext).decode('utf-8')

def import_keys(pub_file: str, priv_file: str):
    """Imports RSA keys from the specified files.
    If either file path is empty or invalid, that key is skipped."""
    # Handle public key import
    if pub_file and pub_file != '""':
        pub_path = Path(pub_file).resolve()
        if pub_path.exists():
            # Avoid copying if the source and destination are the same file
            if pub_path != PUBLIC_KEY_FILE.resolve():
                shutil.copyfile(pub_path, PUBLIC_KEY_FILE)
        else:
            raise FileNotFoundError(f"Public key file not found: {pub_file}")
    
    # Handle private key import
    if priv_file and priv_file != '""':
        priv_path = Path(priv_file).resolve()
        if priv_path.exists():
            # Avoid copying if the source and destination are the same file
            if priv_path != PRIVATE_KEY_FILE.resolve():
                shutil.copyfile(priv_path, PRIVATE_KEY_FILE)
        else:
            raise FileNotFoundError(f"Private key file not found: {priv_file}")

def export_keys(output_dir: str):
    """Exports the current RSA keys to the specified directory.
    Only exports keys that are currently loaded."""
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    exported_files = []
    
    if PRIVATE_KEY_FILE.exists():
        shutil.copyfile(PRIVATE_KEY_FILE, output_path / "private_rsa.pem")
        exported_files.append("private_rsa.pem")
        
    if PUBLIC_KEY_FILE.exists():
        shutil.copyfile(PUBLIC_KEY_FILE, output_path / "public_rsa.pem")
        exported_files.append("public_rsa.pem")
    
    if not exported_files:
        raise FileNotFoundError("No keys found to export. Generate or import keys first.")
        
    return exported_files
